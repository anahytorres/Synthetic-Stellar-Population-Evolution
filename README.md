# Monte Carlo Stellar Population & Remnants 

A compact, reproducible Monte Carlo pipeline to sample an initial stellar population, evolve it to compact remnants (WD/NS/BH) with simple, literature‑based relations, and visualize key distributions. The workflow centers on a Jupyter notebook designed for clarity, reproducibility, and extensibility.

Main notebook: `MONTE CARLO.ipynb`

## Highlights

- Kroupa (2001) initial‑mass function (IMF) sampling with continuity across power‑law breaks (no “bump”).
- Constant SFR birth times (uniform in 0–10 Gyr) and a simple MS lifetime law to decide which stars have evolved.
- Deterministic channel selection + randomized tie‑breaks when IFMR ranges overlap.
- Literature IFMRs/remnant relations (Kalirai 2008; Raithel 2018) and simple BH mass fits.
- Five pre‑packaged plots generated with a single call for fast exploration.

## Quick Start

- Requirements: Python ≥ 3.9, Jupyter, NumPy, Matplotlib
  
  ```bash
  python -m venv .venv
  . .venv/bin/activate  # Windows: .venv\Scripts\activate
  pip install jupyter numpy matplotlib
  jupyter lab  # or: jupyter notebook
  ```
- Open `VER 23-11-remnants-fixed.ipynb`
- Run all cells. The last cell calls `generate_all_plots()` to render Plots 1–5.

## Methodology

### IMF and Mass Sampling

- Base IMF: Kroupa (2001) piecewise power‑law with breaks at 0.08 and 0.5 M☉.
  
  Segments `(m_low, m_high, α)`:
  
  - (0.01, 0.08, 0.3)
  - (0.08, 0.5, 1.3)
  - (0.5, 120.0, 2.3)

- Continuity amplitudes: for segment i with amplitude Aᵢ and break b between i and i+1,
  
  `A_{i+1} = A_i · b^{(α_{i+1} − α_i)}` with `A_0 = 1`.

- Segment probability weights use `Aᵢ · ∫ m^{−αᵢ} dm` over the active mass range; samples are drawn by:
  
  1. Choosing a segment via the normalized weights.
  2. Inverse‑CDF sampling within that segment.

- Result: no density discontinuity at the breaks; the histogram matches the normalized Kroupa PDF.

### Ages, Main‑Sequence Lifetime, and Remnants

- Birth times (constant SFR): `U(0, 10 Gyr)`
- MS lifetime: `t_MS(M) = 10 Gyr · (M/M☉)^{−2.5}` (simple power law).
- A star is a remnant if `age > t_MS`.

### IFMRs and Channels

Masses in solar units (M☉). Selection keeps the channel structure and resolves overlaps randomly.

- WD (Kalirai 2008): `M_f = 0.109 M_i + 0.394`, active for `M_i ∈ [0.5, 9]`.
- NS (Raithel 2018): piecewise branches
  - Eq. 11: `M_f = 2.24 + 0.508 Δ + 0.125 Δ² + 0.0110 Δ³`, where `Δ = M_i − 14.75`, active [9, 13]
  - Eq. 12: `M_f = 0.123 + 0.112 M_i`, active [13, 15]
  - Eq. 13: `M_f = 0.996 + 0.0384 M_i`, active [15, 17.8]
  - Eq. 14: `M_f = −0.020 + 0.10 M_i`, active [17.8, 18.5]
- BH (simple fits)
  - Low mass (15–42.22): mixture of core and total‑mass fits
    - Core: `M_f = −2.049 + 0.4140 M_i`
    - Total (poly): `M_f = 15.52 + 0.3294 δ − 0.02121 δ² + 0.003120 δ³`, with `δ = M_i − 25.97`
    - Mixture: `M_f = f_eject · Core + (1 − f_eject) · Total` (default `f_eject = 0.9`)
  - High mass (≥ 42.22): `M_f = 5.697 + 7.8598e8 · M_i^{−4.858}`

Tie‑breaks: If multiple channels are valid for a star (range overlap), a random valid channel is chosen.

## Plots (Generated by `generate_all_plots()`)

1. Kroupa sampling diagnostics (histogram vs. normalized Kroupa PDF)
2. IFMR scatter: initial vs. final mass, colored by remnant type
3. Final mass vs. time since MS turnoff (log–log)
4. Population split by type vs. initial mass (stacked view with top panel of global fractions)
5. Population split by type vs. final mass (same stacked layout)

You can adjust binning, sample sizes, and styles by editing the plotting functions in the notebook.

## Reproducibility & Tuning

- RNG: a global `rng = np.random.default_rng(2024)` is used for reproducibility.
- Sample size: change `size` in `sample_kroupa_masses`.
- Mass range: set `m_min`, `m_max` in the same call.
- SFR: change the birth‑time draw; e.g. replace uniform with a custom SFH CDF.
- Remnant boundaries: edit `REMNANT_CHANNELS` to adjust mass ranges or add/remove channels.
- BH ejection fraction: tweak `f_eject` in `bh_mass_low`.

## Project Layout

```
.
├── MONTE CARLO.ipynb   # Reorganized notebook

├── flowchart                   # flowchart of the code 
└── README.md                         # This file
```

## Assumptions & Limitations

- IMF and lifetimes are simplified; metallicity effects are ignored.
- IFMR/channel boundaries are approximate and overlap handling is randomized.
- Constant SFR is a placeholder; plug in your SFH for science use.
- Units: masses in M☉, times in Gyr.

## Extending the Model

- Replace constant SFR with an SFH (e.g., exponential, bursty, or empirical).
- Swap the MS lifetime law for a mass/metallicity grid (e.g., isochrones).
- Add metallicity‑dependent IFMRs and channel boundaries.
- Persist samples and figures; add CLI wrappers or Python modules if desired.

## Contributing

- Issues and PRs are welcome. Please keep PRs focused and accompany changes with brief notes.
- Suggestions: new IFMRs, SFHs, channel models, validation notebooks.
